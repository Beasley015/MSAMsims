iris.pca <- PCA(iris2, scale.unit = T, graph = F)
#Look at eigenvalues
iris.pca$eig
#scree plot for visualization
fviz_screeplot(iris.pca, ncp = 4)
plot.PCA(iris.pca, axes = c(1,2), choix = "var")
#biplot
fviz_pca(iris.pca)
#Clean it up
fviz_pca_var(iris.pca, col.var = "contrib")
#Clean it up with a scale showing relative contributions
fviz_pca_var(iris.pca, col.var = "contrib")+
scale_color_gradient2(low = "blue", mid = "steelblue", high = "red",
midpoint = 25)+
theme_bw()
#individual data points without lables
fviz_pca_ind(iris.pca, label = "none")
#add some color to make clusters more informative
fviz_pca_ind(iris.pca, label = "none", habillage = iris$Species)
#add some color to make clusters more informative
fviz_pca_ind(iris.pca, label = "none", habillage = iris$Species, ellipseCA(0.95))
#add some color to make clusters more informative
fviz_pca_ind(iris.pca, label = "none", habillage = iris$Species, ellipse.level = 0.95
)
#add some color to make clusters more informative
fviz_pca_ind(iris.pca, label = "none", habillage = iris$Species, addEllipses = T
ellipse.level = 0.95)
#add some color to make clusters more informative
fviz_pca_ind(iris.pca, label = "none", habillage = iris$Species, addEllipses = T,
ellipse.level = 0.95)
fviz_pca_biplot(iris.pca, geom.ind = "point", fill.ind = iris$Species,
col.ind = "black", addEllipses = T, col.var = "contrib")
#Creating web-based graphs with plotly----------------------------------
library(plotly)
install.packages("plotly")
#Creating web-based graphs with plotly----------------------------------
#load packas
library(plotly)
data(mpg)
data <- mpg
p <- plot_ly(data = mpg, x = ~displ, y = ~cty)
p
#plotly also interacts with ggplot with ggplotly
p2 <- ggplotly(data = mpg, aes(x = displ, y = cty))
#plotly also interacts with ggplot with ggplotly
p2 <- ggplot(data = mpg, aes(x = displ, y = cty))+
geom_point()
ggplotly(p2)
#plotly also interacts with ggplot with ggplotly
p2 <- ggplot(data = mpg, aes(x = displ, y = cty, color = manufacturer))+
geom_point()
ggplotly(p2)
head(txhousing)
tx <- txhousing
allCities <- txhousing %>%
group_by(city) %>%
plot_ly(x = ~date, y = ~median)
allcities
allCities
#3d plots
plot_ly(data = iris, x = ~sepal.length, y = ~sepal.width, z = ~petal.length,
type = "scatter3d", mode = "markers", size = petal.width, color = ~Species)
#3d plots
plot_ly(data = iris, x = ~Sepal.Length, y = ~Sepal.Width, z = ~Petal.Length,
type = "scatter3d", mode = "markers", size = Petal.Width, color = ~Species)
#3d plots
plot_ly(data = iris, x = ~Sepal.Length, y = ~Sepal.Width, z = ~Petal.Length,
type = "scatter3d", mode = "markers", size = ~Petal.Width, color = ~Species)
#Animations
df <- data.frame(x = c(1:5, 4:1), y = c(1:5, 4:1), f = (a:9))
#Animations
df <- data.frame(x = c(1:5, 4:1), y = c(1:5, 4:1), f = (1:9))
p <- plot_ly(data = df, x = ~x, y = ~y, frame = ~f, type = "scatter",
transition = ~f, mode = "markers", showleged = T)
p
install.packages("Plot3D")
install.packages("plot3D")
install.packages("plot3Drgl")
install.packages("diffdf")
install.packages("ggtree")
install.packages"treeio"
install.packages("treeio")
install.packages(emojifont)
install.packages("emojifont")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("ggtree", version = "3.8")
library(betapart)
# Setup -------------------------------------------------------------------------
library(vcdExtra)
library(msm)
library(tidyverse)
set.seed(15)
# Global variables --------------------------------------------------------------
#Mammal
mamm.specs <- 10
sites <- 30
trap.nights <- 3
mamm.genera <- c("genus1", "genus2")
#Ecto
ecto.specs <- 15
life.history <- c("generalist", "specialist", "neither")
# Simulate "true" mammal abundances ---------------------------------------------
mean.lambdas <- rlogseries(mamm.specs, 0.75)
#Draw lambdas from a logseries distribution
alpha0 <- log(mean.lambdas) #log-scale intercept
#abundance responses to any covariates would go here as alpha1, alpha2, etc
log.lambdas <- alpha0  #this is your log link function. add covs here
lambdas <- exp(log.lambdas)  #inverse link transformation
#most of these steps won't matter until covs are added
#create list of abundance vectors
nlist<-list()
for(a in 1:mamm.specs){
nlist[[a]] <- rpois(n = sites, lambda = lambdas[a])
}
#turn abundance vectors into abundance matrix
ns<-do.call(rbind, nlist)
#convert into long format
long.ns <- gather(as.data.frame(ns[,c(1:30)]), key = "Site", value = "Abundance")
long.ns$Species <- rep(1:mamm.specs, sites)
long.ns %>%
arrange(Species) %>%
{. ->> long.ns}
# Simulate mammal observation process (detection error) ---------------------------
#simulate mean detection probs
mean.det <- runif(n = mamm.specs, min = 0.4, max = 0.8)
#These are mid to high detection probabilities
beta0<-qlogis(mean.det) #put it on logit scale
#responses to detection covs would go here
logit.p<-beta0 #logit link function. Det covs go here
p <- plogis(logit.p) #Transform it back
#Simulate observation data
L<-list()
for(b in 1:mamm.specs){
y<-matrix(NA, ncol = trap.nights, nrow = sites)
for(a in 1:trap.nights){
y[,a]<-rbinom(n = sites, size = ns[b,], prob = p[b])
}
L[[b]]<-y
}
#Smash it into array
obsdata<-array(as.numeric(unlist(L)), dim=c(sites, trap.nights, mamm.specs))
long.obs <- matrix(ncol = 3)
for(i in 1:dim(obsdata)[3]){
long.obs <- rbind(long.obs, obsdata[,,i])
}
long.obs <- long.obs[-1,]
# Occupancy probs for each host/ecto species pair ---------------------------------
#Generate name vectors for mammals and ectos
mamm.names <- logical()
for(i in 1:mamm.specs){
mamm.names[i] <- as.character(paste("Mamm", i, sep = ""))
}
ecto.names <- logical()
for(i in 1:ecto.specs){
ecto.names[i] <- as.character(paste("Ecto", i, sep = ""))
}
#Generate mammal and ecto data frames
mammdat <- data.frame(mammspec = mamm.names,
mammgenus = sample(mamm.genera, size = mamm.specs,
replace = T))
ectodat <- data.frame(ecto.names = ecto.names,
life.history = sample(life.history, size = ecto.specs,
replace = T))
#Generate occupancy probabilities. Commence for loop of hell.
genus <- logical()
occprobs <- matrix(NA, nrow = ecto.specs, ncol = mamm.specs)
for(i in 1:ecto.specs){
#Assign a mammal genus to the ecto species
genus <- sample(mammdat$mammgenus, size = 1)
#Generalist species: can occupy all species in a genus
if(ectodat$life.history[i] == "generalist"){
#Generate occupancy probs for all mamm in the genus
for(j in 1:mamm.specs){
if(mammdat$mammgenus[j] == genus){
occprobs[i,j] <- runif(1, 0, 1)
} else{
occprobs[i,j] <- 0
}
}
#Specialist species: Only one host
} else if(ectodat$life.history[i] == "specialist"){
#Generate an occupancy prob for a single host
host <- sample(mammdat$mammspec, size = 1)
for(j in 1:length(mammdat$mammspec))
if(mammdat$mammspec[j] == host){
occprobs[i,j] <- runif(1,0,1)
} else{
occprobs[i,j] <- 0
}
#"Neither" category: one primary and one secondary host
} else if(ectodat$life.history[i] == "neither"){
#Generate occupancy prob for a primary and secondary host
somehosts <- sample(which(mammdat$mammgenus == genus), size = 2)
occprobs[i, somehosts[1]] <- runif(1, 0.5, 1) #primary host
occprobs[i, somehosts[2]] <- runif(1, 0, 0.5) #secondary host
occprobs[is.na(occprobs)] <- 0
}
}
# Get occupancy probabilities for each host population based on above matrix -----
popprobs <- function(x, y, z, mat){
pop.array <- array(dim = c(x, y, z))
for(i in 1:x){
for(j in 1:y){
for(k in 1:z){
if(mat[k,i] != 0){
pop.array[i,j,k] <- rtnorm(n = 1, mean = mat[k,i], sd = 0.05,
lower = 0, upper = 1)
#Use a truncated normal distribution to make sure it's a probability
#May use a different distribution later
} else{
pop.array[i,j,k] <- 0
}
}
}
}
#Convert array to a matrix
popoccs <- matrix(NA, nrow = x*y, ncol = z)
for(i in 1:z){
popoccs[,i] <- as.vector(pop.array[,,i])
}
popoccs <- as.data.frame(popoccs)
}
pop.probs <- popprobs(x = mamm.specs, y = sites, z = ecto.specs, mat = occprobs)
#Make sure ecto occupancy prob is 0 if there are no hosts present
for(i in 1:(mamm.specs*sites)){
if(long.ns$Abundance[i] == 0){
pop.probs[i,] <- rep(0, ecto.specs)
}
}
# Use occupancy probs to get "true" presence/absence data
occstate <- matrix(NA, nrow = mamm.specs*sites, ncol = ecto.specs)
for(i in 1:(mamm.specs*sites)){
for(j in 1:ecto.specs){
occstate[i,j] <- as.numeric(rbernoulli(n = 1, p = pop.probs[i,j]))
}
}
#Create "true" ecto occupancy for individual rodents -------------------------
#Simulate mean occupancy prob for each ectoparasite
#Same individual host prob regardless of host species
ind.occ <- runif(n = ecto.specs, min = 0.3, max = 0.6)
#These are quite high but I want at least some non-zero data to wor with
#Parasites also tend to aggregate, but for now I'm not messing with that
#Create detection histories
L <- list()
for(i in 1:ecto.specs){
y <- matrix(NA, nrow = (mamm.specs*sites), ncol = max(long.ns$Abundance))
for(k in 1:(mamm.specs*sites)){
for(j in 1:long.ns$Abundance[k]){
y[k,j] <- as.numeric(rbernoulli(n = 1, p = ind.occ[i]*occstate[k,i]))
}
}
L[[i]] <- y
}
#Change list of matrices into array
ind.obs<-array(unlist(L), dim=c(mamm.specs*sites, max(long.ns$Abundance),
ecto.specs))
# Create probability of detecting an ecto at each capture -----------------------
#Create individual mammal IDs
IDs <- list()
for(i in 1:length(long.ns$Abundance)){
if(long.ns$Abundance[i] != 0){
IDs[[i]] <- seq(1:long.ns$Abundance[i])
} else{
IDs[[i]] <- NA
}
}
#Find out which individuals of the population were sampled during period k
samples <- list()
for(i in 1:length(IDs)){
samples[[i]] <- list()
for(j in 1:dim(long.obs)[2]){
if(is.na(IDs[[i]]) == F){
samples[[i]][[j]] <- sample(IDs[[i]], size = long.obs[i,j])
} else{
samples[[i]] <- NA
}
}
}
install.packages("popbio")
#Load libraries
library(tidyverse)
library(patchwork)
library(betapart)
install.packages("caret")
install.packages("rpart")
library(devtools)
install_github("dphansti/Sushi")
library(vcdExtra)
library(TeachingDemos)
library(ggplot2)
library(R2OpenBUGS)
setwd("c:/users/beasley/dropbox/MSAMsims")
#Global variables: sites, survey, seed ----------------------------------------
J <- 30 #sites
K <- 3 #surveys per site
specs<-10 #Number of species
Ks<-rep(K, J) #Ks is a vector of length J indicationg # of sampling periods per site
set.seed(15) #insures sim is same each time
#Simulating abundance data ---------------------------------------------------
mean.lambdas <- rlogseries(n = specs, prob = 0.75)
#create covariates
cov1<-rnorm(n = J, mean = 10, sd = 5)
cov1scale <- as.vector(scale(cov1))
cov2 <- rnorm(n = J, mean = 5, sd = 1)
cov2scale <- as.vector(scale(cov2))
#create responses to covariates
alpha0 <- log(mean.lambdas) #log-scale intercept
#All species have negative response
alpha1 <- rep(-1, specs)
#Only two species respond
alpha2 <- c(rep(2, 2), rnorm(n = specs-2, mean = 0, sd = 0.1))
#Put covs and responses in log link function
log.lambdas <- matrix(NA, nrow = specs, ncol = J)
for(i in 1:specs){
log.lambdas[i,] <- alpha0[i] + alpha1[i]*cov1scale + alpha2[i]*cov2scale
}
#inverse link transformation
lambdas <- exp(log.lambdas)
#create list of abundance vectors
ns <- matrix(NA, nrow = specs, ncol = J)
for(a in 1:specs){
ns[a,] <- rpois(n = J, lambda = lambdas[a,])
}
rowSums(ns) #total abundances
rotate.ns<-t(ns)
#Simulated observation process --------------------------------------------
mean.det <- runif(n = specs, min = 0.4, max = 0.9) #simulate mean detection probs
#These are mid to high detection values
#Detection intercept and cov responses
beta0<-qlogis(mean.det) #put it on logit scale
#Detection cov, but it does not affect detectability
beta1 <- rnorm(n = specs, mean = 0, sd = 0.01)
detcov <- matrix(runif(J*K, 0, 10), nrow = J, ncol = K)
#Logit link function
logit.p <- array(NA, dim = c(J, K, specs))
for(i in 1:specs){
logit.p[,,i] <- beta0[i] + beta1[i]*detcov
}
p <- plogis(logit.p)
#Simulate observation data
L<-list()
for(b in 1:specs){
y<-matrix(NA, ncol = K, nrow = J)
for(a in 1:K){
y[,a]<-rbinom(n = J, size = ns[b,], prob = p[,,b])
}
L[[b]]<-y
}
#Smash it into array
obsdata<-array(as.numeric(unlist(L)), dim=c(J, K, specs))
#Convert obsdata into abundance matrix
maxobs<-apply(obsdata, c(1,3), max)
#Run the model ------------------------------------------------------------
#Write model
cat("
model{
#Define prior distributions
#Intercepts
a0.mean ~ dnorm(0,0.001)
sigma.a0 ~ dunif(0,10)
tau.a0 <- 1/(sigma.a0*sigma.a0)
b0.mean ~ dnorm(0,0.001)
sigma.b0 ~ dunif(0,10)
tau.b0 <- 1/(sigma.b0*sigma.b0)
#Covs
a1.mean ~ dnorm(0, 0.1)
sigma.a1 ~ dunif(0,10)
tau.a1 <- 1/(sigma.a1*sigma.a1)
a2.mean ~ dnorm(0, 0.1)
sigma.a2 ~ dunif(0,10)
tau.a2 <- 1/(sigma.a2*sigma.a2)
b1.mean ~ dnorm(0, 0.1)
sigma.b1 ~ dunif(0,10)
tau.b1 <- 1/(sigma.b1*sigma.b1)
for(i in 1:specs){
#create priors from distributions above
a0[i] ~ dnorm(a0.mean, tau.a0)
a1[i] ~ dnorm(a1.mean, tau.a1)
a2[i] ~ dnorm(a2.mean, tau.a2)
b0[i] ~ dnorm(b0.mean, tau.b0)
b1[i] ~ dnorm(b1.mean, tau.b1)
#Loop within a loop to estimate abund of spec i at site j
for(j in 1:J){
log(lambda[j,i]) <- a0[i] + a1[i]*cov1[j] + a2[i]*cov2[j]
Z[j,i] ~ dpois(lambda[j,i])
#Loop within loops for estimating det of spec i at site j at time k
for(k in 1:K[j]){
p[j,k,i] <- b0[i] + b1[i]*detcov[j,k]
logit.p[j,k,i] <- 1 / (1 + exp(-p[j,k,i]))
obsdata[j,k,i] ~ dbin(logit.p[j,k,i], Z[j,i])
}
}
}
}
", file = "abundmitcovs.txt")
#Compile data into list
datalist<-list(specs=specs, J=J, K=Ks, obsdata=obsdata, cov1 = cov1scale,
cov2 = cov2scale, detcov = detcov)
#Specify parameters
params<-list('Z','lambda','a0','b0', 'a0.mean', 'b0.mean', 'a1', 'a2', 'b1')
#Specify initial values
init.values<-function(){
list(a0 = rnorm(n = specs, mean = mean(alpha0)),
b0 = rnorm(n = specs, mean = mean(beta0)),
a1 = rnorm(n = specs), a2 = rnorm(n = specs), b1 = rnorm(n = specs),
Z = matrix(maxobs, nrow = J, ncol = specs)
)
}
#Send model to Gibbs sampler
mod1<-bugs(model.file = "abundmitcovs.txt", data = datalist, inits = init.values,
parameters.to.save = params, n.chains = 3, n.burnin = 3000,
n.iter = 6000, debug = T)
mod1
saveRDS(mod1, file = "covmodel.RDS")
#Send model to Gibbs sampler
mod1<-bugs(model.file = "abundmitcovs.txt", data = datalist, inits = init.values,
parameters.to.save = params, n.chains = 3, n.burnin = 2000,
n.iter = 6000, debug = T)
mod1
saveRDS(mod1, file = "covmodel.RDS")
#Send model to Gibbs sampler
mod1<-bugs(model.file = "abundmitcovs.txt", data = datalist, inits = init.values,
parameters.to.save = params, n.chains = 3, n.burnin = 2000,
n.iter = 5000, debug = T)
mod1
mod1
mod1 <- readRDS(file = "covmodel.RDS")
mod1
#Send model to Gibbs sampler
mod1<-bugs(model.file = "abundmitcovs.txt", data = datalist, inits = init.values,
parameters.to.save = params, n.chains = 3, n.burnin = 2000,
n.iter = 7000, debug = T)
mod1
mod1 <- readRDS(file = "covmodel.RDS")
#Test model accuracy -------------------------------------------------------
a1s <- mod1$sims.list$a1
mean.a1 <- apply(a1s, 2, mean)
lo.a1 <- apply(a1s, 2, quantile, 0.025)
hi.a1 <- apply(a1s, 2, quantile, 0.975)
ggplot()+
geom_point(aes(x = 1:10, y = alpha1), color = "red")+
geom_point(aes(x = 1:10, y = mean.a1))+
geom_errorbar(aes(x = 1:10, ymin = lo.a1, ymax = hi.a1))
a2s <- mod1$sims.list$a2
mean.a2 <- apply(a2s, 2, mean)
lo.a2 <- apply(a2s, 2, quantile, 0.025)
lo.a2 <- apply(a2s, 2, quantile, 0.025)
hi.a2 <- apply(a2s, 2, quantile, 0.975)
ggplot()+
geom_point(aes(x = 1:10, y = alpha2), color = "red")+
geom_point(aes(x = 1:10, y = mean.a2))+
geom_errorbar(aes(x = 1:10, ymin = lo.a2, ymax = hi.a2))
colSums(ns)
rowSums(ns)
mean.a2
lo.a2
b1s <- mod1$sims.list$b1
mean.b1 <- apply(b1s, 2, mean)
lo.b1 <- apply(b1s, quantile, 0.025)
hi.b1 <- apply(b1s, quantile, 0.975)
ggplot()+
geom_point(aes(x = 1:10, y = beta1), color = "red")+
geom_point(aes(x = 1:10, y = mean.b1))+
geom_errorbar(aes(x = 1:10, ymin = lo.b1, ymax = hi.b1))
b1s <- mod1$sims.list$b1
mean.b1 <- apply(b1s, 2, mean)
lo.b1 <- apply(b1s, quantile, 0.025)
hi.b1 <- apply(b1s, quantile, 0.975)
ggplot()+
geom_point(aes(x = 1:10, y = beta1), color = "red")+
geom_point(aes(x = 1:10, y = mean.b1))+
geom_errorbar(aes(x = 1:10, ymin = lo.b1, ymax = hi.b1))
lo.b1 <- apply(b1s, 2, quantile, 0.025)
hi.b1 <- apply(b1s, 2, quantile, 0.975)
ggplot()+
geom_point(aes(x = 1:10, y = beta1), color = "red")+
geom_point(aes(x = 1:10, y = mean.b1))+
geom_errorbar(aes(x = 1:10, ymin = lo.b1, ymax = hi.b1))
#Test model assumptions ----------------------------------------------------
#Is estimated abundance closer to the true value than observed?
Z <- mod1$sims.list$Z
mean.Z <- apply(Z, c(2,3), mean)
site.mean <- apply(mean.Z, 1, sum)
site.true <- colSums(ns)
site.obs <- apply(maxobs, 1, sum)
site.comp <- data.frame(rank(site.true), site.mean, site.obs, site.true)
colnames(site.comp) <- c("sites.ranked", "site.mean", "site.obs", "site.true")
ggplot(data = site.comp, aes(x = sites.ranked))+
geom_point(aes(y = site.mean, fill = "Estimated", color = "Estimated"))+
geom_smooth(aes(y = site.mean, fill = "Estimated", color = "Estimated"),
show.legend = F)+
geom_point(aes(y = site.obs, fill = "Observed", color = "Observed"))+
geom_smooth(aes(y = site.obs, fill = "Observed", color = "Observed"),
show.legend = F)+
geom_point(aes(y = site.true, fill = "True", color = "True"))+
geom_smooth(aes(y = site.true, fill = "True", color = "True"), show.legend= F)+
scale_fill_manual(breaks = c("Estimated", "Observed", "True"),
values = c("blue", "black", "red"), guide = F)+
scale_color_manual(breaks = c("Estimated", "Observed", "True"),
values = c("blue", "black", "red"))+
labs(x = "Sites (Ranked)", y = "Abundance")+
theme_bw()+
theme(legend.title = element_blank())
#Is there a 1:1 relationship between estimated and true abundance?
linears <- data.frame(as.vector(t(ns)),as.vector(apply(Z, c(2,3), mean)))
colnames(linears) <- c("True", "Estimated")
ggplot(data = linears, aes(x = True, y = Estimated))+
geom_point()+
geom_smooth(method = 'lm')+
theme_bw()
summary(lm(data = linears, Estimated~True))
